<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Retro Raycaster - Improved</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background: #000; overflow: hidden; color: white; font-family: 'Courier New', Courier, monospace; touch-action: none; }
        canvas { display: block; image-rendering: pixelated; width: 100vw; height: 100vh; }
        
        #menu {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        .btn {
            background: #a00; color: white; border: none; padding: 20px 40px;
            margin: 10px; font-size: 24px; cursor: pointer; font-family: inherit; transition: 0.3s;
        }
        .btn:hover { background: #f00; }

        #ui { 
            position: absolute; bottom: 20px; left: 20px; 
            pointer-events: none; text-shadow: 2px 2px 2px black; z-index: 10;
        }
        #health-bar { width: 200px; height: 20px; background: #300; border: 2px solid white; margin-bottom: 5px; }
        #health-fill { width: 100%; height: 100%; background: #f00; transition: width 0.3s; }
        
        #joystick-container {
            position: absolute; bottom: 40px; left: 40px;
            width: 120px; height: 120px; background: rgba(255,255,255,0.1);
            border-radius: 50%; display: none; touch-action: none; border: 2px solid rgba(255,255,255,0.3);
        }
        #joystick-stick {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px; background: rgba(255,255,255,0.4);
            border-radius: 50%; transform: translate(-50%, -50%);
        }

        #shoot-btn {
            position: absolute; bottom: 40px; right: 40px;
            width: 100px; height: 100px; border-radius: 50%; 
            background: rgba(255,0,0,0.5); border: 4px solid white;
            display: none; align-items: center; justify-content: center;
            font-size: 40px; user-select: none; z-index: 20;
        }

        #crosshair { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: lime; font-size: 24px; font-weight: bold; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="menu">
        <h1>RETRO RAYCASTER</h1>
        <button class="btn" onclick="startGame('pc')">–ò–ì–†–ê–¢–¨ (–ü–ö: WASD + –ú—ã—à—å)</button>
        <button class="btn" onclick="startGame('mobile')">–ò–ì–†–ê–¢–¨ (–¢–ï–õ–ï–§–û–ù)</button>
    </div>

    <div id="joystick-container"><div id="joystick-stick"></div></div>
    <div id="shoot-btn">üî•</div>

    <canvas id="screen"></canvas>
    <div id="crosshair">+</div>
    <div id="ui">
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo-display">AMMO: 10/30</div>
    </div>

    <script>
        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d');
        const screenWidth = 320, screenHeight = 200;
        canvas.width = screenWidth; canvas.height = screenHeight;

        // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø—Ä–∞–π—Ç–∞ –≤—Ä–∞–≥–∞
        const enemySprite = new Image();
        enemySprite.src = 'furry.jpg';

        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,2,0,0,1,0,2,0,2,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
            [1,0,2,0,0,0,0,1,0,0,0,0,2,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let player = { x: 2, y: 2, dir: 0, speed: 0.07, health: 100 };
        let joyPos = { x: 0, y: 0 }, isTouchingJoy = false;
        let ammo = 10, reserveAmmo = 30, gameRunning = false, isMobile = false;
        let enemies = [], flash = 0;
        let zBuffer = new Array(screenWidth);
        const keys = {};

        function startGame(mode) {
            isMobile = mode === 'mobile';
            document.getElementById('menu').style.display = 'none';
            if (isMobile) {
                document.getElementById('joystick-container').style.display = 'block';
                document.getElementById('shoot-btn').style.display = 'flex';
                setupMobileControls();
            } else {
                canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
                canvas.onclick = () => canvas.requestPointerLock();
            }
            gameRunning = true;
            loop();
        }

        function setupMobileControls() {
            const joy = document.getElementById('joystick-container');
            const stick = document.getElementById('joystick-stick');
            const shootBtn = document.getElementById('shoot-btn');

            joy.ontouchstart = (e) => { isTouchingJoy = true; };
            window.addEventListener('touchmove', (e) => {
                let touches = e.touches;
                for(let i=0; i<touches.length; i++) {
                    if (touches[i].clientX < window.innerWidth/2) {
                        let rect = joy.getBoundingClientRect();
                        let dx = touches[i].clientX - (rect.left + rect.width/2);
                        let dy = touches[i].clientY - (rect.top + rect.height/2);
                        let dist = Math.min(60, Math.hypot(dx, dy));
                        let angle = Math.atan2(dy, dx);
                        joyPos.x = (Math.cos(angle) * dist) / 60;
                        joyPos.y = (Math.sin(angle) * dist) / 60;
                        stick.style.transform = `translate(calc(-50% + ${joyPos.x*60}px), calc(-50% + ${joyPos.y*60}px))`;
                    } else {
                        if (touches[i].lastX) player.dir += (touches[i].clientX - touches[i].lastX) * 0.01;
                        touches[i].lastX = touches[i].clientX;
                    }
                }
            });
            window.addEventListener('touchend', () => { 
                isTouchingJoy = false; joyPos = {x:0, y:0}; 
                stick.style.transform = 'translate(-50%, -50%)';
            });
            shootBtn.ontouchstart = (e) => { e.preventDefault(); shoot(); };
        }

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => { 
            if (document.pointerLockElement === canvas) player.dir += e.movementX * 0.003; 
        });
        window.addEventListener('mousedown', e => {
            if (gameRunning && !isMobile) shoot();
        });

        function shoot() {
            if (ammo <= 0 || player.health <= 0) return;
            ammo--; 
            flash = 5;
            updateUI();
            
            enemies.forEach(en => {
                let dx = en.x - player.x, dy = en.y - player.y;
                let angle = Math.atan2(dy, dx) - player.dir;
                while (angle < -Math.PI) angle += Math.PI * 2;
                while (angle > Math.PI) angle -= Math.PI * 2;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (en.alive && Math.abs(angle) < 0.2 && dist < 10) {
                    en.alive = false;
                    if (ammo < 10) ammo += 1;
                }
            });
        }

        function updateUI() {
            document.getElementById('ammo-display').innerText = `AMMO: ${ammo}/${reserveAmmo}`;
            document.getElementById('health-fill').style.width = player.health + "%";
            if (player.health <= 0) {
                alert("–í–´ –ü–û–ì–ò–ë–õ–ò");
                location.reload();
            }
        }

        function isWall(x, y) {
            if (x < 0 || x >= 15 || y < 0 || y >= 7) return true;
            return map[Math.floor(y)][Math.floor(x)] !== 0;
        }

        function update() {
            if (!gameRunning) return;
            let mx = 0, my = 0;

            if (isMobile) {
                let moveX = -joyPos.y * Math.cos(player.dir) + joyPos.x * Math.cos(player.dir + Math.PI/2);
                let moveY = -joyPos.y * Math.sin(player.dir) + joyPos.x * Math.sin(player.dir + Math.PI/2);
                mx = moveX * player.speed;
                my = moveY * player.speed;
            } else {
                if (keys['KeyW']) { mx += Math.cos(player.dir); my += Math.sin(player.dir); }
                if (keys['KeyS']) { mx -= Math.cos(player.dir); my -= Math.sin(player.dir); }
                if (keys['KeyA']) { mx += Math.cos(player.dir - Math.PI/2); my += Math.sin(player.dir - Math.PI/2); }
                if (keys['KeyD']) { mx += Math.cos(player.dir + Math.PI/2); my += Math.sin(player.dir + Math.PI/2); }
                
                let mag = Math.sqrt(mx*mx + my*my);
                if (mag > 0) { mx = (mx/mag) * player.speed; my = (my/mag) * player.speed; }
            }
            
            if (!isWall(player.x + mx * 2, player.y)) player.x += mx;
            if (!isWall(player.x, player.y + my * 2)) player.y += my;

            enemies.forEach(en => {
                if (!en.alive) return;
                let dx = player.x - en.x, dy = player.y - en.y, d = Math.sqrt(dx*dx + dy*dy);
                if (d < 0.6) { player.health -= 0.5; updateUI(); }
                else { en.x += (dx/d)*0.02; en.y += (dy/d)*0.02; }
            });

            if (Math.random() < 0.01 && enemies.filter(e=>e.alive).length < 5) {
                enemies.push({x: 13, y: 3, alive: true});
            }
            if (flash > 0) flash--;
        }

        function draw() {
            let skyGrd = ctx.createLinearGradient(0, 0, 0, screenHeight/2);
            skyGrd.addColorStop(0, "#001133");
            skyGrd.addColorStop(1, "#330000");
            ctx.fillStyle = skyGrd;
            ctx.fillRect(0,0,screenWidth,screenHeight/2);

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0,screenHeight/2,screenWidth,screenHeight/2);

            for (let i = 0; i < screenWidth; i++) {
                let angle = (player.dir - 0.5) + (i / screenWidth);
                let d = 0, hit = 0;
                let step = 0.05;
                while (hit === 0 && d < 15) {
                    d += step;
                    let testX = player.x + Math.cos(angle)*d;
                    let testY = player.y + Math.sin(angle)*d;
                    if (testX < 0 || testX >= 15 || testY < 0 || testY >= 7) { hit = 1; d = 15; }
                    else {
                        hit = map[Math.floor(testY)][Math.floor(testX)];
                    }
                }
                
                zBuffer[i] = d * Math.cos(angle - player.dir);
                let h = screenHeight / zBuffer[i];
                
                let color = 150 / (1 + d * 0.2); 
                if (hit === 1) ctx.fillStyle = `rgb(${color}, ${color*0.2}, ${color*0.2})`; 
                else if (hit === 2) ctx.fillStyle = `rgb(${color*0.2}, ${color*0.8}, ${color})`; 
                
                ctx.fillRect(i, screenHeight/2 - h/2, 1, h);
            }

            // –†–µ–Ω–¥–µ—Ä –≤—Ä–∞–≥–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–∞—Ä—Ç–∏–Ω–∫–∏ furry.jpg
            enemies.sort((a, b) => {
                let distA = Math.hypot(a.x - player.x, a.y - player.y);
                let distB = Math.hypot(b.x - player.x, b.y - player.y);
                return distB - distA;
            });

            enemies.forEach(en => {
                if (!en.alive) return;
                let dx = en.x - player.x, dy = en.y - player.y, dist = Math.sqrt(dx*dx+dy*dy);
                let ang = Math.atan2(dy, dx) - player.dir;
                while (ang < -Math.PI) ang += Math.PI*2;
                while (ang > Math.PI) ang -= Math.PI*2;
                
                if (Math.abs(ang) < 1) {
                    let sx = (ang + 0.5) * screenWidth;
                    let h = screenHeight / dist;
                    let w = h; // –ö–≤–∞–¥—Ä–∞—Ç–Ω—ã–π —Å–ø—Ä–∞–π—Ç
                    
                    let screenX = Math.floor(sx);
                    if (dist > 0.2 && screenX >= 0 && screenX < screenWidth && zBuffer[screenX] > dist) {
                        try {
                            ctx.drawImage(enemySprite, sx - w/2, screenHeight/2 - h/2, w, h);
                        } catch (e) {
                            // –ï—Å–ª–∏ –∫–∞—Ä—Ç–∏–Ω–∫–∞ –Ω–µ –≥—Ä—É–∑–∏—Ç—Å—è, —Ä–∏—Å—É–µ–º –∫–≤–∞–¥—Ä–∞—Ç
                            ctx.fillStyle = 'white';
                            ctx.fillRect(sx - w/2, screenHeight/2 - h/2, w, h);
                        }
                    }
                }
            });

            if (flash > 0) {
                ctx.fillStyle = `rgba(255,255,200,${flash*0.1})`;
                ctx.fillRect(0,0,screenWidth,screenHeight);
            }
        }

        function loop() {
            if (gameRunning) {
                update(); 
                draw(); 
            }
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>