<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Retro Raycaster - Victory & Tactics</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background: #000; overflow: hidden; color: white; font-family: 'Courier New', Courier, monospace; touch-action: none; }
        canvas { display: block; image-rendering: pixelated; width: 100vw; height: 100vh; }
        
        #menu, #pause-menu {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        #pause-menu { display: none; background: rgba(0,0,0,0.7); }

        .btn {
            background: #a00; color: white; border: none; padding: 15px 30px;
            margin: 10px; font-size: 20px; cursor: pointer; font-family: inherit; transition: 0.3s;
            width: 250px;
        }
        .btn:hover { background: #f00; }

        .settings-row { margin: 10px; display: flex; flex-direction: column; align-items: center; }
        input[type=range] { width: 200px; cursor: pointer; }

        #ui { 
            position: absolute; bottom: 20px; left: 20px; 
            pointer-events: none; text-shadow: 2px 2px 2px black; z-index: 10;
        }
        #health-bar { width: 200px; height: 20px; background: #300; border: 2px solid white; margin-bottom: 5px; }
        #health-fill { width: 100%; height: 100%; background: #f00; transition: width 0.3s; }
        
        /* –ö–Ω–æ–ø–∫–∞ –º–µ–Ω—é –¥–ª—è –º–æ–±–∏–ª–æ–∫ */
        #mobile-menu-btn {
            position: absolute; top: 10px; right: 10px; width: 50px; height: 50px;
            background: rgba(255,255,255,0.2); border: 1px solid white; color: white;
            display: none; align-items: center; justify-content: center; z-index: 50; border-radius: 5px;
        }

        #joystick-container {
            position: absolute; bottom: 40px; left: 40px;
            width: 120px; height: 120px; background: rgba(255,255,255,0.1);
            border-radius: 50%; display: none; touch-action: none; border: 2px solid rgba(255,255,255,0.3);
        }
        #joystick-stick {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px; background: rgba(255,255,255,0.4);
            border-radius: 50%; transform: translate(-50%, -50%);
        }

        #shoot-btn, #reload-btn {
            position: absolute; border-radius: 50%; 
            background: rgba(255,0,0,0.5); border: 4px solid white;
            display: none; align-items: center; justify-content: center;
            user-select: none; z-index: 20; touch-action: none;
        }
        #shoot-btn { bottom: 40px; right: 40px; width: 100px; height: 100px; font-size: 40px; }
        #reload-btn { bottom: 150px; right: 55px; width: 70px; height: 70px; font-size: 25px; background: rgba(0,100,255,0.5); }

        #crosshair { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: lime; font-size: 24px; font-weight: bold; pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é -->
    <div id="menu">
        <h1>–£–±–µ–π —Ñ—É—Ä—Ä–∏: –ú–∏—Å—Å–∏—è –∑–∞—á–∏—Å—Ç–∫–∏</h1>
        <p>by: Karton820</p>
        <button class="btn" onclick="startGame('pc')">–ò–ì–†–ê–¢–¨ (–ü–ö)</button>
        <button class="btn" onclick="startGame('mobile')">–ò–ì–†–ê–¢–¨ (–¢–ï–õ–ï–§–û–ù)</button>
    </div>

    <!-- –ú–µ–Ω—é –ø–∞—É–∑—ã -->
    <div id="pause-menu">
        <h2>–ü–ê–£–ó–ê</h2>
        <div class="settings-row">
            <label>–ì—Ä–æ–º–∫–æ—Å—Ç—å –∑–≤—É–∫–æ–≤</label>
            <input type="range" id="vol-sound" min="0" max="1" step="0.1" value="0.5">
        </div>
        <div class="settings-row">
            <label>–ì—Ä–æ–º–∫–æ—Å—Ç—å –º—É–∑—ã–∫–∏</label>
            <input type="range" id="vol-music" min="0" max="1" step="0.1" value="0.5">
        </div>
        <div class="settings-row">
            <label>–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å</label>
            <input type="range" id="sens" min="0.1" max="2.0" step="0.1" value="1.0">
        </div>
        <button class="btn" onclick="togglePause()">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
        <button class="btn" onclick="location.reload()" style="background:#555">–í –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ</button>
    </div>

    <div id="mobile-menu-btn" onclick="togglePause()">‚öôÔ∏è</div>

    <div id="joystick-container"><div id="joystick-stick"></div></div>
    <div id="shoot-btn">üî•</div>
    <div id="reload-btn">üîÑ</div>

    <canvas id="screen"></canvas>
    <div id="crosshair">+</div>
    <div id="ui">
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo-display">AMMO: 10/30 | KILLS: 0/15</div>
    </div>

    <script>
        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d');
        const screenWidth = 320, screenHeight = 200;
        canvas.width = screenWidth; canvas.height = screenHeight;

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
        let settings = { volume: 0.5, music: 0.5, sens: 1.0 };
        let isPaused = false;

        const enemySprite = new Image();
        enemySprite.src = 'furry.jpg';
        const itemSprite = new Image();
        itemSprite.src = 'item.jpg';

        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,0,0,1,0,2,0,2,0,1,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1],
            [1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,1,0,1,0,1],
            [1,0,2,0,0,0,0,1,0,0,0,0,0,0,2,0,0,0,0,1],
            [1,0,0,0,1,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1],
            [1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,1],
            [1,0,0,0,1,0,2,0,2,0,0,1,0,0,0,0,1,0,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        const mapW = map[0].length;
        const mapH = map.length;

        let player = { x: 2, y: 2, dir: 0, speed: 0.07, health: 100 };
        let joyPos = { x: 0, y: 0 };
        let ammo = 10, reserveAmmo = 30, gameRunning = false, isMobile = false;
        let enemiesKilled = 0;
        const killsToWin = 15;
        
        let enemies = [];
        let items = [
            {x: 8, y: 2, type: 'ammo', collected: false},
            {x: 14, y: 3, type: 'medkit', collected: false},
            {x: 3, y: 8, type: 'ammo', collected: false},
            {x: 18, y: 1, type: 'medkit', collected: false}
        ];
        let flash = 0;
        let zBuffer = new Array(screenWidth);
        const keys = {};
        let lastTouchX = null;

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫
        document.getElementById('vol-sound').oninput = (e) => settings.volume = e.target.value;
        document.getElementById('vol-music').oninput = (e) => settings.music = e.target.value;
        document.getElementById('sens').oninput = (e) => settings.sens = e.target.value;

        function togglePause() {
            if (!gameRunning) return;
            isPaused = !isPaused;
            document.getElementById('pause-menu').style.display = isPaused ? 'flex' : 'none';
            if (!isPaused && !isMobile) canvas.requestPointerLock();
            if (isPaused) document.exitPointerLock?.();
        }

        function startGame(mode) {
            isMobile = mode === 'mobile';
            document.getElementById('menu').style.display = 'none';
            if (isMobile) {
                document.getElementById('joystick-container').style.display = 'block';
                document.getElementById('shoot-btn').style.display = 'flex';
                document.getElementById('reload-btn').style.display = 'flex';
                document.getElementById('mobile-menu-btn').style.display = 'flex';
                setupMobileControls();
            } else {
                canvas.onclick = () => { if(!isPaused) canvas.requestPointerLock(); }
            }
            gameRunning = true;
            loop();
        }

        function setupMobileControls() {
            window.addEventListener('touchstart', (e) => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    let t = e.changedTouches[i];
                    if (t.clientX > window.innerWidth / 2) lastTouchX = t.clientX;
                }
            }, {passive: false});

            window.addEventListener('touchmove', (e) => {
                if (isPaused) return;
                e.preventDefault();
                for(let i=0; i<e.touches.length; i++) {
                    let t = e.touches[i];
                    if (t.clientX < window.innerWidth/2) {
                        let rect = document.getElementById('joystick-container').getBoundingClientRect();
                        let dx = t.clientX - (rect.left + rect.width/2);
                        let dy = t.clientY - (rect.top + rect.height/2);
                        let dist = Math.min(60, Math.hypot(dx, dy));
                        let angle = Math.atan2(dy, dx);
                        joyPos.x = (Math.cos(angle) * dist) / 60;
                        joyPos.y = (Math.sin(angle) * dist) / 60;
                        document.getElementById('joystick-stick').style.transform = `translate(calc(-50% + ${joyPos.x*60}px), calc(-50% + ${joyPos.y*60}px))`;
                    } else if (lastTouchX !== null) {
                        let dx = t.clientX - lastTouchX;
                        player.dir += dx * 0.007 * settings.sens;
                        lastTouchX = t.clientX;
                    }
                }
            }, {passive: false});

            window.addEventListener('touchend', (e) => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    let t = e.changedTouches[i];
                    if (t.clientX < window.innerWidth/2) {
                        joyPos = {x:0, y:0};
                        document.getElementById('joystick-stick').style.transform = 'translate(-50%, -50%)';
                    } else lastTouchX = null;
                }
            });

            document.getElementById('shoot-btn').addEventListener('touchstart', (e) => { e.preventDefault(); if(!isPaused) shoot(); });
            document.getElementById('reload-btn').addEventListener('touchstart', (e) => { e.preventDefault(); if(!isPaused) reload(); });
        }

        window.addEventListener('keydown', e => {
            if (e.code === 'Escape') togglePause();
            keys[e.code] = true;
            if (e.code === 'KeyR' && !isPaused) reload();
        });
        window.addEventListener('keyup', e => keys[e.code] = false);
        
        window.addEventListener('mousemove', e => { 
            if (document.pointerLockElement === canvas && !isPaused) {
                player.dir += e.movementX * 0.003 * settings.sens; 
            }
        });

        function reload() {
            if (ammo === 10 || reserveAmmo <= 0) return;
            let needed = 10 - ammo;
            let toReload = Math.min(needed, reserveAmmo);
            ammo += toReload;
            reserveAmmo -= toReload;
            updateUI();
        }

        function shoot() {
            if (ammo <= 0 || player.health <= 0 || isPaused) return;
            ammo--; 
            flash = 5;
            
            let nearestEnemy = null;
            let minDist = 10;

            enemies.forEach(en => {
                if (!en.alive) return;
                let dx = en.x - player.x, dy = en.y - player.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let angle = Math.atan2(dy, dx) - player.dir;
                while (angle < -Math.PI) angle += Math.PI * 2;
                while (angle > Math.PI) angle -= Math.PI * 2;

                if (Math.abs(angle) < 0.2 && dist < minDist) {
                    if (dist < getWallDist(angle + player.dir)) {
                        minDist = dist;
                        nearestEnemy = en;
                    }
                }
            });

            if (nearestEnemy) {
                nearestEnemy.alive = false;
                enemiesKilled++;
                if (Math.random() > 0.7) {
                    items.push({x: nearestEnemy.x, y: nearestEnemy.y, type: Math.random() > 0.5 ? 'ammo' : 'medkit', collected: false});
                }
            }
            updateUI();
        }

        function getWallDist(angle) {
            let d = 0, step = 0.1;
            while (d < 15) {
                d += step;
                let tx = Math.floor(player.x + Math.cos(angle)*d);
                let ty = Math.floor(player.y + Math.sin(angle)*d);
                if (tx<0 || tx>=mapW || ty<0 || ty>=mapH || map[ty][tx] > 0) return d;
            }
            return 15;
        }

        function updateUI() {
            document.getElementById('ammo-display').innerText = `AMMO: ${ammo}/${reserveAmmo} | KILLS: ${enemiesKilled}/${killsToWin}`;
            document.getElementById('health-fill').style.width = player.health + "%";
            
            if (enemiesKilled >= killsToWin) {
                gameRunning = false;
                alert("–û–¢–õ–ò–ß–ù–û! –¢—ã –∑–∞—á–∏—Å—Ç–∏–ª —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—é.");
                location.reload();
            }
            if (player.health <= 0) {
                alert("–í–´ –ü–û–ì–ò–ë–õ–ò");
                location.reload();
            }
        }

        function isWall(x, y) {
            if (x < 0 || x >= mapW || y < 0 || y >= mapH) return true;
            return map[Math.floor(y)][Math.floor(x)] !== 0;
        }

        function update() {
            if (!gameRunning || isPaused) return;
            let mx = 0, my = 0;

            if (isMobile) {
                let moveX = -joyPos.y * Math.cos(player.dir) + joyPos.x * Math.cos(player.dir + Math.PI/2);
                let moveY = -joyPos.y * Math.sin(player.dir) + joyPos.x * Math.sin(player.dir + Math.PI/2);
                mx = moveX * player.speed;
                my = moveY * player.speed;
            } else {
                if (keys['KeyW']) { mx += Math.cos(player.dir); my += Math.sin(player.dir); }
                if (keys['KeyS']) { mx -= Math.cos(player.dir); my -= Math.sin(player.dir); }
                if (keys['KeyA']) { mx += Math.cos(player.dir - Math.PI/2); my += Math.sin(player.dir - Math.PI/2); }
                if (keys['KeyD']) { mx += Math.cos(player.dir + Math.PI/2); my += Math.sin(player.dir + Math.PI/2); }
                let mag = Math.sqrt(mx*mx + my*my);
                if (mag > 0) { mx = (mx/mag) * player.speed; my = (my/mag) * player.speed; }
            }
            
            if (!isWall(player.x + mx * 2, player.y)) player.x += mx;
            if (!isWall(player.x, player.y + my * 2)) player.y += my;

            items.forEach(item => {
                if (!item.collected) {
                    let d = Math.hypot(player.x - item.x, player.y - item.y);
                    if (d < 0.5) {
                        item.collected = true;
                        if (item.type === 'medkit') player.health = Math.min(100, player.health + 30);
                        if (item.type === 'ammo') reserveAmmo += 20;
                        updateUI();
                    }
                }
            });

            enemies.forEach(en => {
                if (!en.alive) return;
                let dx = player.x - en.x, dy = player.y - en.y, d = Math.sqrt(dx*dx + dy*dy);
                if (d < 0.6) { player.health -= 0.4; updateUI(); } 
                else if (d < 8) {
                    en.x += (dx/d)*0.018;
                    en.y += (dy/d)*0.018;
                }
            });

            if (Math.random() < 0.008 && enemies.filter(e=>e.alive).length < 6) {
                let rx = Math.random() * mapW, ry = Math.random() * mapH;
                if (!isWall(rx, ry) && Math.hypot(rx-player.x, ry-player.y) > 5) enemies.push({x: rx, y: ry, alive: true});
            }
            if (flash > 0) flash--;
        }

        function draw() {
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–æ–ª–∞ –∏ –ø–æ—Ç–æ–ª–∫–∞
            ctx.fillStyle = "#220033"; ctx.fillRect(0, 0, screenWidth, screenHeight/2);
            ctx.fillStyle = "#111"; ctx.fillRect(0, screenHeight/2, screenWidth, screenHeight/2);

            // –°—Ç–µ–Ω—ã (Raycasting)
            for (let i = 0; i < screenWidth; i++) {
                let angle = (player.dir - 0.5) + (i / screenWidth);
                let d = 0, hit = 0, step = 0.05;
                while (hit === 0 && d < 15) {
                    d += step;
                    let tx = Math.floor(player.x + Math.cos(angle)*d);
                    let ty = Math.floor(player.y + Math.sin(angle)*d);
                    if (tx < 0 || tx >= mapW || ty < 0 || ty >= mapH) { hit = 1; d = 15; }
                    else hit = map[ty][tx];
                }
                zBuffer[i] = d * Math.cos(angle - player.dir);
                let h = screenHeight / zBuffer[i];
                let c = 180 / (1 + d * 0.25);
                ctx.fillStyle = (hit === 1) ? `rgb(${c}, ${c*0.2}, ${c*0.2})` : `rgb(${c*0.3}, ${c*0.3}, ${c*0.8})`;
                ctx.fillRect(i, screenHeight/2 - h/2, 1, h);
            }

            // –°–ø—Ä–∞–π—Ç—ã (–í—Ä–∞–≥–∏ –∏ –ø—Ä–µ–¥–º–µ—Ç—ã)
            let sprites = [];
            enemies.forEach(e => { if(e.alive) sprites.push({...e, type: 'enemy'})});
            items.forEach(it => { if(!it.collected) sprites.push({...it, type: it.type})});
            
            sprites.sort((a, b) => Math.hypot(b.x - player.x, b.y - player.y) - Math.hypot(a.x - player.x, a.y - player.y));

            sprites.forEach(s => {
                let dx = s.x - player.x, dy = s.y - player.y;
                let dist = Math.hypot(dx, dy);
                let angle = Math.atan2(dy, dx) - player.dir;
                while (angle < -Math.PI) angle += Math.PI*2;
                while (angle > Math.PI) angle -= Math.PI*2;

                if (Math.abs(angle) < 1.2) {
                    let sx = (angle + 0.5) * screenWidth;
                    let h = screenHeight / dist;
                    if (dist > 0.2 && sx > -h && sx < screenWidth + h && zBuffer[Math.floor(sx) || 0] > dist) {
                        if (s.type === 'enemy') ctx.drawImage(enemySprite, sx - h/2, screenHeight/2 - h/2, h, h);
                        else ctx.drawImage(itemSprite, sx - h/4, screenHeight/2 + h/4, h/2, h/2);
                    }
                }
            });

            if (flash > 0) { ctx.fillStyle = `rgba(255,255,255,${flash*0.1})`; ctx.fillRect(0,0,screenWidth,screenHeight); }
            if (isPaused) { ctx.fillStyle = "rgba(0,0,0,0.4)"; ctx.fillRect(0,0,screenWidth,screenHeight); }
        }

        function loop() {
            update(); draw();
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>
