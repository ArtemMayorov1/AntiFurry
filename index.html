<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–£–±–µ–π —Ñ—É—Ä—Ä–∏: TT:Karton820</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background: #000; overflow: hidden; color: white; font-family: 'Courier New', Courier, monospace; touch-action: none; }
        canvas { display: block; image-rendering: pixelated; width: 100vw; height: 100vh; }
        
        #menu {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        .btn {
            background: #a00; color: white; border: none; padding: 20px 40px;
            margin: 10px; font-size: 24px; cursor: pointer; font-family: inherit; transition: 0.3s;
        }
        .btn:hover { background: #f00; }
        
        .btn-support {
            background: #444; font-size: 18px; padding: 10px 20px;
        }
        .btn-support:hover { background: #666; }

        #ui { 
            position: absolute; bottom: 20px; left: 20px; 
            pointer-events: none; text-shadow: 2px 2px 2px black; z-index: 10;
        }
        #health-bar { width: 200px; height: 20px; background: #300; border: 2px solid white; margin-bottom: 5px; }
        #health-fill { width: 100%; height: 100%; background: #f00; transition: width 0.3s; }
        
        #joystick-container {
            position: absolute; bottom: 40px; left: 40px;
            width: 120px; height: 120px; background: rgba(255,255,255,0.1);
            border-radius: 50%; display: none; touch-action: none; border: 2px solid rgba(255,255,255,0.3);
        }
        #joystick-stick {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px; background: rgba(255,255,255,0.4);
            border-radius: 50%; transform: translate(-50%, -50%);
        }

        #shoot-btn, #reload-btn {
            position: absolute; border-radius: 50%; 
            background: rgba(255,0,0,0.5); border: 4px solid white;
            display: none; align-items: center; justify-content: center;
            user-select: none; z-index: 20; touch-action: none;
        }
        #shoot-btn { bottom: 40px; right: 40px; width: 100px; height: 100px; font-size: 40px; }
        #reload-btn { bottom: 150px; right: 55px; width: 70px; height: 70px; font-size: 25px; background: rgba(0,100,255,0.5); }

        #crosshair { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: lime; font-size: 24px; font-weight: bold; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="menu">
        <h1>–£–±–µ–π —Ñ—É—Ä—Ä–∏: –ú–∏—Å—Å–∏—è –∑–∞—á–∏—Å—Ç–∫–∏ by:Karton820</h1>
        <p>–¶–µ–ª—å: –£–Ω–∏—á—Ç–æ–∂–∏—Ç—å 15 –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–≤</p>
        <button class="btn" onclick="startGame('pc')">–ò–ì–†–ê–¢–¨ (–ü–ö)</button>
        <button class="btn" onclick="startGame('mobile')">–ò–ì–†–ê–¢–¨ (–¢–ï–õ–ï–§–û–ù)</button>
        <button class="btn btn-support" onclick="window.open('https://www.donationalerts.com/r/karton820', '_blank')">–ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å –∞–≤—Ç–æ—Ä–∞</button>
    </div>

    <div id="joystick-container"><div id="joystick-stick"></div></div>
    <div id="shoot-btn">üî•</div>
    <div id="reload-btn">üîÑ</div>

    <canvas id="screen"></canvas>
    <div id="crosshair">+</div>
    <div id="ui">
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo-display">AMMO: 10/30 | KILLS: 0/15</div>
    </div>

    <script>
        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d');
        const screenWidth = 320, screenHeight = 200;
        canvas.width = screenWidth; canvas.height = screenHeight;

        // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø—Ä–∞–π—Ç–æ–≤
        const enemySprite = new Image();
        enemySprite.src = 'furry.jpg';
        const itemSprite = new Image();
        itemSprite.src = 'item.jpg'; // –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–∞—à —Å–ø—Ä–∞–π—Ç –¥–ª—è –ø–∞—Ç—Ä–æ–Ω–æ–≤ –∏ –∞–ø—Ç–µ—á–µ–∫

        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,0,0,1,0,2,0,2,0,1,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1],
            [1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,1,0,1,0,1],
            [1,0,2,0,0,0,0,1,0,0,0,0,0,0,2,0,0,0,0,1],
            [1,0,0,0,1,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1],
            [1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,1],
            [1,0,0,0,1,0,2,0,2,0,0,1,0,0,0,0,1,0,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        const mapW = map[0].length;
        const mapH = map.length;

        let player = { x: 2, y: 2, dir: 0, speed: 0.07, health: 100 };
        let joyPos = { x: 0, y: 0 };
        let ammo = 10, reserveAmmo = 30, gameRunning = false, isMobile = false;
        let enemiesKilled = 0;
        const killsToWin = 15;
        
        let enemies = [];
        let items = [
            {x: 8, y: 2, type: 'ammo', collected: false},
            {x: 14, y: 3, type: 'medkit', collected: false},
            {x: 3, y: 8, type: 'ammo', collected: false},
            {x: 18, y: 1, type: 'medkit', collected: false}
        ];
        let flash = 0;
        let zBuffer = new Array(screenWidth);
        const keys = {};
        let lastTouchX = null;

        function startGame(mode) {
            isMobile = mode === 'mobile';
            document.getElementById('menu').style.display = 'none';
            if (isMobile) {
                document.getElementById('joystick-container').style.display = 'block';
                document.getElementById('shoot-btn').style.display = 'flex';
                document.getElementById('reload-btn').style.display = 'flex';
                setupMobileControls();
            } else {
                canvas.onclick = () => canvas.requestPointerLock();
            }
            gameRunning = true;
            loop();
        }

        function setupMobileControls() {
            const joy = document.getElementById('joystick-container');
            const stick = document.getElementById('joystick-stick');
            const shootBtn = document.getElementById('shoot-btn');
            const reloadBtn = document.getElementById('reload-btn');

            window.addEventListener('touchstart', (e) => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    let t = e.changedTouches[i];
                    if (t.clientX > window.innerWidth / 2) lastTouchX = t.clientX;
                }
            }, {passive: false});

            window.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let i=0; i<e.touches.length; i++) {
                    let t = e.touches[i];
                    if (t.clientX < window.innerWidth/2) {
                        let rect = joy.getBoundingClientRect();
                        let dx = t.clientX - (rect.left + rect.width/2);
                        let dy = t.clientY - (rect.top + rect.height/2);
                        let dist = Math.min(60, Math.hypot(dx, dy));
                        let angle = Math.atan2(dy, dx);
                        joyPos.x = (Math.cos(angle) * dist) / 60;
                        joyPos.y = (Math.sin(angle) * dist) / 60;
                        stick.style.transform = `translate(calc(-50% + ${joyPos.x*60}px), calc(-50% + ${joyPos.y*60}px))`;
                    } else if (lastTouchX !== null) {
                        let dx = t.clientX - lastTouchX;
                        player.dir += dx * 0.007;
                        lastTouchX = t.clientX;
                    }
                }
            }, {passive: false});

            window.addEventListener('touchend', (e) => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    let t = e.changedTouches[i];
                    if (t.clientX < window.innerWidth/2) {
                        joyPos = {x:0, y:0};
                        stick.style.transform = 'translate(-50%, -50%)';
                    } else lastTouchX = null;
                }
            });

            shootBtn.addEventListener('touchstart', (e) => { e.preventDefault(); shoot(); });
            reloadBtn.addEventListener('touchstart', (e) => { e.preventDefault(); reload(); });
        }

        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'KeyR') reload();
        });
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => { 
            if (document.pointerLockElement === canvas) player.dir += e.movementX * 0.003; 
        });
        window.addEventListener('mousedown', e => {
            if (gameRunning && !isMobile) shoot();
        });

        function reload() {
            if (ammo === 10 || reserveAmmo <= 0) return;
            let needed = 10 - ammo;
            let toReload = Math.min(needed, reserveAmmo);
            ammo += toReload;
            reserveAmmo -= toReload;
            updateUI();
        }

        function shoot() {
            if (ammo <= 0 || player.health <= 0) return;
            ammo--; 
            flash = 5;
            
            let nearestEnemy = null;
            let minDist = 10;

            enemies.forEach(en => {
                if (!en.alive) return;
                let dx = en.x - player.x, dy = en.y - player.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let angle = Math.atan2(dy, dx) - player.dir;
                while (angle < -Math.PI) angle += Math.PI * 2;
                while (angle > Math.PI) angle -= Math.PI * 2;

                if (Math.abs(angle) < 0.15 && dist < minDist) {
                    if (dist < getWallDist(angle + player.dir)) {
                        minDist = dist;
                        nearestEnemy = en;
                    }
                }
            });

            if (nearestEnemy) {
                nearestEnemy.alive = false;
                enemiesKilled++;
                if (Math.random() > 0.7) {
                    items.push({x: nearestEnemy.x, y: nearestEnemy.y, type: Math.random() > 0.5 ? 'ammo' : 'medkit', collected: false});
                }
            }
            updateUI();
        }

        function getWallDist(angle) {
            let d = 0, step = 0.1;
            while (d < 15) {
                d += step;
                let tx = Math.floor(player.x + Math.cos(angle)*d);
                let ty = Math.floor(player.y + Math.sin(angle)*d);
                if (tx<0 || tx>=mapW || ty<0 || ty>=mapH || map[ty][tx] > 0) return d;
            }
            return 15;
        }

        function updateUI() {
            document.getElementById('ammo-display').innerText = `AMMO: ${ammo}/${reserveAmmo} | KILLS: ${enemiesKilled}/${killsToWin}`;
            document.getElementById('health-fill').style.width = player.health + "%";
            
            if (enemiesKilled >= killsToWin) {
                gameRunning = false;
                alert("–û–¢–õ–ò–ß–ù–û! –¢—ã —Ç–µ–ø–µ—Ä—å PozziPrime.");
                location.reload();
            }
            if (player.health <= 0) {
                alert("–í–´ –ü–û–ì–ò–ë–õ–ò");
                location.reload();
            }
        }

        function isWall(x, y) {
            if (x < 0 || x >= mapW || y < 0 || y >= mapH) return true;
            return map[Math.floor(y)][Math.floor(x)] !== 0;
        }

        function update() {
            if (!gameRunning) return;
            let mx = 0, my = 0;

            if (isMobile) {
                let moveX = -joyPos.y * Math.cos(player.dir) + joyPos.x * Math.cos(player.dir + Math.PI/2);
                let moveY = -joyPos.y * Math.sin(player.dir) + joyPos.x * Math.sin(player.dir + Math.PI/2);
                mx = moveX * player.speed;
                my = moveY * player.speed;
            } else {
                if (keys['KeyW']) { mx += Math.cos(player.dir); my += Math.sin(player.dir); }
                if (keys['KeyS']) { mx -= Math.cos(player.dir); my -= Math.sin(player.dir); }
                if (keys['KeyA']) { mx += Math.cos(player.dir - Math.PI/2); my += Math.sin(player.dir - Math.PI/2); }
                if (keys['KeyD']) { mx += Math.cos(player.dir + Math.PI/2); my += Math.sin(player.dir + Math.PI/2); }
                let mag = Math.sqrt(mx*mx + my*my);
                if (mag > 0) { mx = (mx/mag) * player.speed; my = (my/mag) * player.speed; }
            }
            
            if (!isWall(player.x + mx * 2, player.y)) player.x += mx;
            if (!isWall(player.x, player.y + my * 2)) player.y += my;

            // –°–±–æ—Ä –ø—Ä–µ–¥–º–µ—Ç–æ–≤
            items.forEach(item => {
                if (!item.collected) {
                    let d = Math.hypot(player.x - item.x, player.y - item.y);
                    if (d < 0.5) {
                        item.collected = true;
                        if (item.type === 'medkit') player.health = Math.min(100, player.health + 30);
                        if (item.type === 'ammo') reserveAmmo += 20;
                        updateUI();
                    }
                }
            });

            // –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç –≤—Ä–∞–≥–æ–≤: –î–≤–∏–∂–µ–Ω–∏–µ –±–µ–∑ —Ç–æ–ª–∫—É—á–∫–∏
            enemies.forEach(en => {
                if (!en.alive) return;
                let dx = player.x - en.x, dy = player.y - en.y, d = Math.sqrt(dx*dx + dy*dy);
                
                if (d < 0.6) { 
                    player.health -= 0.4; 
                    updateUI(); 
                } else if (d < 8) {
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –±–ª–∏–∑–æ—Å—Ç—å –¥—Ä—É–≥–∏—Ö –≤—Ä–∞–≥–æ–≤ (separation)
                    let tooClose = false;
                    for(let other of enemies) {
                        if (other !== en && other.alive) {
                            let distOther = Math.hypot(en.x - other.x, en.y - other.y);
                            if (distOther < 0.5) { tooClose = true; break; }
                        }
                    }
                    
                    // –ï—Å–ª–∏ —Ä—è–¥–æ–º –Ω–∏–∫–æ–≥–æ –Ω–µ—Ç, –∏–¥–µ–º –∫ –∏–≥—Ä–æ–∫—É –º–µ–¥–ª–µ–Ω–Ω–µ–µ
                    if (!tooClose) {
                        en.x += (dx/d)*0.018;
                        en.y += (dy/d)*0.018;
                    } else {
                        // –ï—Å–ª–∏ –≤ —Ç–æ–ª–ø–µ - –Ω–µ–º–Ω–æ–≥–æ —Å–º–µ—â–∞–µ–º—Å—è –≤ —Å—Ç–æ—Ä–æ–Ω—É
                        en.x += (dy/d)*0.01;
                        en.y -= (dx/d)*0.01;
                    }
                }
            });

            // –°–ø–∞–≤–Ω –Ω–æ–≤—ã—Ö –≤—Ä–∞–≥–æ–≤ –¥–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞ –ø–æ–±–µ–¥—ã
            if (Math.random() < 0.008 && enemies.filter(e=>e.alive).length < 5) {
                let rx = Math.random() > 0.5 ? 18 : 2;
                let ry = Math.random() > 0.5 ? 8 : 5;
                if (!isWall(rx, ry)) enemies.push({x: rx, y: ry, alive: true});
            }
            if (flash > 0) flash--;
        }

        function drawSprite(x, y, type, dist, zBuffer) {
            let dx = x - player.x, dy = y - player.y;
            let ang = Math.atan2(dy, dx) - player.dir;
            while (ang < -Math.PI) ang += Math.PI*2;
            while (ang > Math.PI) ang -= Math.PI*2;

            if (Math.abs(ang) < 1.2) {
                let sx = (ang + 0.5) * screenWidth;
                let h = screenHeight / dist;
                let w = h;
                let screenX = Math.floor(sx);
                if (dist > 0.2 && screenX >= 0 && screenX < screenWidth && zBuffer[screenX] > dist) {
                    if (type === 'enemy') {
                        try { ctx.drawImage(enemySprite, sx - w/2, screenHeight/2 - h/2, w, h); }
                        catch(e) { ctx.fillStyle = 'red'; ctx.fillRect(sx - w/2, screenHeight/2 - h/2, w, h); }
                    } else {
                        // –†–∏—Å—É–µ–º –≤–∞—à —Å–ø—Ä–∞–π—Ç –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–æ–≤
                        try { 
                            let itemW = w/2;
                            ctx.drawImage(itemSprite, sx - itemW/2, screenHeight/2 + h/4, itemW, itemW); 
                        } catch(e) { 
                            ctx.fillStyle = (type === 'medkit') ? '#0f0' : '#ff0';
                            ctx.fillRect(sx - w/4, screenHeight/2 + h/4, w/2, h/4);
                        }
                    }
                }
            }
        }

        function draw() {
            let skyGrd = ctx.createLinearGradient(0, 0, 0, screenHeight/2);
            skyGrd.addColorStop(0, "#000511");
            skyGrd.addColorStop(1, "#220033");
            ctx.fillStyle = skyGrd;
            ctx.fillRect(0,0,screenWidth,screenHeight/2);
            ctx.fillStyle = '#111';
            ctx.fillRect(0,screenHeight/2,screenWidth,screenHeight/2);

            for (let i = 0; i < screenWidth; i++) {
                let angle = (player.dir - 0.5) + (i / screenWidth);
                let d = 0, hit = 0, step = 0.05;
                while (hit === 0 && d < 15) {
                    d += step;
                    let tx = Math.floor(player.x + Math.cos(angle)*d);
                    let ty = Math.floor(player.y + Math.sin(angle)*d);
                    if (tx < 0 || tx >= mapW || ty < 0 || ty >= mapH) { hit = 1; d = 15; }
                    else hit = map[ty][tx];
                }
                zBuffer[i] = d * Math.cos(angle - player.dir);
                let h = screenHeight / zBuffer[i];
                let c = 180 / (1 + d * 0.25);
                if (hit === 1) ctx.fillStyle = `rgb(${c}, ${c*0.3}, ${c*0.3})`;
                else if (hit === 2) ctx.fillStyle = `rgb(${c*0.4}, ${c*0.4}, ${c*0.8})`;
                ctx.fillRect(i, screenHeight/2 - h/2, 1, h);
            }

            let sprites = [];
            enemies.forEach(e => { if(e.alive) sprites.push({...e, type: 'enemy'})});
            items.forEach(it => { if(!it.collected) sprites.push({...it, type: it.type})});
            
            sprites.sort((a, b) => {
                let da = Math.hypot(a.x - player.x, a.y - player.y);
                let db = Math.hypot(b.x - player.x, b.y - player.y);
                return db - da;
            });

            sprites.forEach(s => {
                let d = Math.hypot(s.x - player.x, s.y - player.y);
                drawSprite(s.x, s.y, s.type, d, zBuffer);
            });

            if (flash > 0) {
                ctx.fillStyle = `rgba(255,255,200,${flash*0.1})`;
                ctx.fillRect(0,0,screenWidth,screenHeight);
            }
        }

        function loop() {
            if (gameRunning) { update(); draw(); }
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>

